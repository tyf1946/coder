# 从Rxjava到协程的心路历程（无代码）
### Rxjava到了说再见的时候了
#### 异步
先唠嗑两句异步吧，Android初期，那个时代，异步其实并不友好，除了Java基础的那些，就只有handler算是个能打的主。handler本身和view的切合，以及和系统的切合的确是把很快的刀，但快刀并不优雅也不足够灵活，尤其是面对数据库，网络层等复杂情况下，有些捉襟见肘了。但那个时代嘛，android领域很多地方还荒芜的很。
那个时候，Rxjava的出现，的确是时代骄子。不仅搞定了并发，更是优雅的搞定了并发。同时，基于Asyhconization和Composition，也就是异步和组合的方式，使得Rx可以使用操作符进行组合将各种复杂的请求简单化，复杂的逻辑简洁化。
但那个时候到如今也有了数年了，很多新的异步库也不断地出现，在借鉴了rx思想的基础上，出来的java8的CompletableFuture和kotlin的Coroutine协程，与rxjava相比有了不少的优势，更何况google基于此而不断拓展补充的Jetpack，给了Androider者另外的选择。

#### 门槛
那rxjava的劣势是什么呢？四个字：曲高和寡。大白话：设计太过于灵活的东西，学习门槛便太高，太难精通了。
Rxjava的思想设计是非常理想的，让观察模式彻底解耦，一切异步操作由上游控制，下游只需要思考如何处理，并不关心数据来源。（当然，backpress算是破坏这种理想的一种证明）这种理想设计太过于优秀，正如一间房子，就算把它彻彻底底打扫干净，也还是停留在体力活这个层次上，但rxjava是进行无菌消毒的工具…打比方有点偏，领会精神哈…曲高和寡，精通的成本需要Android工程师付出太过于高昂的成本，但说实话，只是为了异步的话。这个付出有点过了。

#### 协同
事实上，学习门槛高这个事儿，真正受影响的，其实是团队，而非个人。还是刚才那个词，曲高和寡，弹奏的固然要是个高高手，但听众也要远远高于普通人，才能听出旋律中的那份宛转，也就是说，rxjava在项目中的应用，不仅仅需要构建结构的高手精通，同时也要应用的协同小伙伴们精通。这个难度，实在是有点太为难小伙伴了。

说到底，还是成本的问题和成本的问题。

### 协程，我们选择的替代者

协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的功能包括：
* **轻量**：您可以在单个线程上运行多个协程，因为协程支持 [挂起]，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。
* **内存泄露更少**：使用 [结构化并发] 机制在一个作用域内执行多个操作。
* **内置取消支持**： [取消]功能会自动通过正在运行的协程层次结构传播。
* **Jetpack 集成**：许多 Jetpack 库都包含提供全面协程支持的 [扩展]。某些库还提供自己的 [协程作用域] ，可供您用于结构化并发。

### 线程的并发不是结构化的
可以想想这几个问题在 Java 中要怎么解决：
1. 结束一个线程时，怎么同时结束这个线程中创建的子线程？
2. 当某个子线程在执行时需要结束兄弟线程要做怎么做？
3. 如何等待所有子线程都执行完了再结束父线程？
这些问题都可以通过共享标记位、CountDownLatch 等方式实现。但这两个例子让我们意识到，线程间没有级联关系；所有线程执行的上下文都是整个进程，多个线程的并发是相对整个进程的，而不是相对某一个父线程。
这就是线程的「非结构化」。